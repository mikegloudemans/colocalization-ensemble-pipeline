# Author: Mike Gloudemans
#
# preprocess.py
#
# Tools for loading summary statistics.
#

import subprocess
import pandas as pd
import operator
import SNP
from scipy import stats
import math
import gzip

import sys
if sys.version_info[0] < 3:
    from StringIO import StringIO
else:
    from io import StringIO

# Load a list of SNPs generated by the "overlap" function,
# to test these SNPs only.
# TODO: Obviate the need for a separate dispatcher script
# altogether by just loading and launching directly from the
# list generated by "overlap"
def select_snps_from_list(list_file):

    gwas_table = pd.read_csv(list_file, sep="\s+", header=None)

    snp_list = zip(list(gwas_table.iloc[:,0]), list(gwas_table.iloc[:,1]), [-1]*gwas_table.shape[0])
    # Filter out X and Y for now
    snp_list = [s for s in snp_list if ("Y" not in str(s[0]) and "X" not in str(s[0]))]
    snp_list = [SNP.SNP(s) for s in snp_list]
    if gwas_table.shape[1] > 2:
        return zip(snp_list, list(gwas_table.iloc[:,2]))
    else:
        return zip(snp_list, [-1]*len(snp_list))

# Input: gwas file location, threshold of significance, minimum distance
# between two selected SNPs.  Output: A list of significant SNPs to test.
def select_test_snps_by_gwas(gwas_file, gwas_threshold, trait, settings, window=1000000):

    print("Selecting GWAS hits from {0}".format(gwas_file))

    with gzip.open(gwas_file) as f:
        #if "debug" in settings and settings["debug"] == "True":
        #    gwas_table = pd.read_csv(f, sep="\t", nrows=500000, dtype=str)
        #else:
        gwas_table = pd.read_csv(f, sep="\t", dtype=str)

    if trait == gwas_file.split("/")[-1]:
        subset = gwas_table[['chr', 'snp_pos', 'pvalue']].copy()
    else:
        subset = gwas_table[['chr', 'snp_pos', 'pvalue', 'trait']].copy()

    subset.loc[:,'pvalue'] = subset.loc[:,'pvalue'].astype(float)
    subset = subset[subset['pvalue'] <= gwas_threshold]
    if trait != gwas_file.split("/")[-1]:
        subset = subset[subset['trait'] == trait]

    all_snps = [tuple(x) for x in subset.values]
    all_snps = sorted(all_snps, key=operator.itemgetter(2))

    # For now, include only autosomal SNPs.
    filtered = []
    for s in all_snps:
        if "chr" in str(s[0]):
            try:
                filtered.append((int(s[0][3:]), s[1], s[2]))
            except:
                pass
        else:
            try:
                filtered.append((int(s[0]), s[1], s[2]))
            except:
                pass

    all_snps = [SNP.SNP(x) for x in filtered]

    # Go through the list of SNPs in order, adding the ones
    # passing our criteria.
    snps_to_test = []
    for snp in all_snps:

        # See if we're done yet
        if snp.pval >= gwas_threshold:
                break

        # For now, ignore a SNP if it's in the MHC region -- this
        # would require alternative methods.
        if (snp.chrom == 6) and snp.pos > 25000000 and snp.pos < 35000000:
                continue

        # Before adding a SNP, make sure it's not right next
        # to another SNP that we've already selected.
        skip = False
        for kept_snp in snps_to_test:
                if kept_snp.chrom == snp.chrom and abs(kept_snp.pos - snp.pos) < window:
                        skip = True
                        break
        if not skip:
                snps_to_test.append(snp)


    # -1 here means unrestricted to a certain gene
    # TODO: Just make this part of the SNP object so that we can test SNP/gene pairs for equality
    snps_to_test = [(s, -1) for s in snps_to_test]

    return snps_to_test

# Load summary statistics for GWAS
def get_gwas_data(gwas_file, snp, settings, trait):

    window = settings["window"]

    # Get GWAS data using tabix

    with gzip.open(gwas_file, 'rb') as gwas:
        header = gwas.readline()

    raw_gwas = subprocess.check_output("tabix {0} {1}:{2}-{3}".format(gwas_file, \
            snp.chrom, max(1, snp.pos - window), snp.pos + window), shell=True) + \
            subprocess.check_output("tabix {0} chr{1}:{2}-{3}".format(gwas_file, \
            snp.chrom, max(1, snp.pos - window), snp.pos + window), shell=True)
    gwas_table = pd.read_csv(StringIO(header + raw_gwas), sep="\t")
    gwas_table['pvalue'] = gwas_table['pvalue'].astype(float)

    if trait != gwas_file.split("/")[-1]:
        gwas_table = gwas_table[gwas_table["trait"] == trait]

    if gwas_table.shape[0] == 0:
        return "No GWAS summary statistics found at this locus."

    gwas_table['snp_pos'] = gwas_table['snp_pos'].astype(int)

    if "effect_allele" in list(gwas_table.columns.values):
        gwas_table['alt'] = gwas_table["effect_allele"].str.upper()
        gwas_table['ref'] = gwas_table["non_effect_allele"].str.upper()

    if 'effect_af' in gwas_table.columns.values:
        gwas_table = gwas_table.rename(index=str, columns={"effect_af": "effect_af_gwas"})

        gwas_table['ref'] = gwas_table['ref'].apply(lambda x: x.upper())
        gwas_table['alt'] = gwas_table['alt'].apply(lambda x: x.upper())

    #
    # 'gwas_format' must be specified, to make sure the users know what they're doing.
    #
    # Possible settings for 'gwas_format':
    #   - case_control
    #   - effect_size
    #   - pval_only (requires effect direction)
    #
    
    if 'zscore' in gwas_table.columns.values:
        gwas_table = gwas_table.rename(index=str, columns={"zscore": "ZSCORE"})

    if settings['gwas_experiments'][gwas_file]['gwas_format'] == 'case_control':
        assert 'log_or' in gwas_table and 'se' in gwas_table
        gwas_table['ZSCORE'] = gwas_table['log_or'] / gwas_table['se']
    elif settings['gwas_experiments'][gwas_file]['gwas_format'] == 'effect_size':
        if "log_or" in gwas_table:
            gwas_table['beta'] = gwas_table['log_or']
        assert 'beta' in gwas_table
        gwas_table['ZSCORE'] = gwas_table['beta'] / gwas_table['se']
        gwas_table['ZSCORE'] = gwas_table['ZSCORE'].fillna(0)
    elif settings['gwas_experiments'][gwas_file]['gwas_format'] == 'pval_only':
        gwas_table = gwas_table[~gwas_table["pvalue"].isna()]

        # Need to cap it at z-score of 40 for outrageous p-values (like with AMD / RPE stuff)
        if "effect_direction" in gwas_table:
            gwas_table['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(gwas_table["pvalue"] / 2)], index=gwas_table.index) * (2*(gwas_table["effect_direction"] == "+")-1)
        elif "beta" in gwas_table:
            # replace beta == NaN with 0 (beta == NaN for large p-values)
            gwas_table = gwas_table.fillna({'beta': 0})
            gwas_table['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(gwas_table["pvalue"] / 2)], index=gwas_table.index) * (2*(gwas_table["beta"] > 0)-1)
        elif "direction" in gwas_table:
            gwas_table['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(gwas_table["pvalue"] / 2)], index=gwas_table.index) * (2*(gwas_table["direction"] == "+")-1)
        else:
            # We don't always need zscore. Like not if running FINEMAP
            pass
    else:
        return "Improper GWAS format specification"
    
    if 'ZSCORE' in gwas_table.columns.values:
        # Derive beta and se from zscore if needed
        if 'se' not in gwas_table.columns.values or 'beta' not in gwas_table.columns.values:
            gwas_table['beta'] = gwas_table['ZSCORE']
            gwas_table['se'] = 1

    if "beta" in gwas_table:
        gwas_table = gwas_table.rename(index=str, columns={"beta": "beta_gwas"})
    if "se" in gwas_table:
        gwas_table = gwas_table.rename(index=str, columns={"se": "se_gwas"})

    return gwas_table

# Load summary statistics for eQTL
def get_eqtl_data(eqtl_file, snp, settings):

    window = settings["window"]

    # Get eQTL data using tabix
    with gzip.open(eqtl_file, 'rb') as eqtl:
        header = eqtl.readline()

    raw_eqtls = subprocess.check_output("tabix {0} {1}:{2}-{3}".format(eqtl_file, \
            snp.chrom, max(1, snp.pos - window), snp.pos + window), shell=True)
    raw_eqtls += subprocess.check_output("tabix {0} chr{1}:{2}-{3}".format(eqtl_file, \
            snp.chrom, max(1, snp.pos - window), snp.pos + window), shell=True)
    eqtl_table = pd.read_csv(StringIO(header + raw_eqtls), sep="\t", index_col=False)

    if eqtl_table.shape[0] == 0:
        return "Gene desert."

    if "effect_allele" in list(eqtl_table.columns.values):
        eqtl_table['alt'] = eqtl_table["effect_allele"].str.upper()
        eqtl_table['ref'] = eqtl_table["non_effect_allele"].str.upper()

    # NOTE: We're not worrying about direction here right now, but might want to later
    if "maf" in eqtl_table.columns.values:
        eqtl_table['effect_af_eqtl'] = eqtl_table['maf']

    if "effect_af" in eqtl_table.columns.values:
        eqtl_table = eqtl_table.rename(index=str, columns={"effect_af": "effect_af_eqtl"})

    if "ref" in eqtl_table.columns.values:
        eqtl_table['ref'] = eqtl_table['ref'].apply(lambda x: x.upper())
        eqtl_table['alt'] = eqtl_table['alt'].apply(lambda x: x.upper())

    eqtl_table['snp_pos'] = eqtl_table['snp_pos'].astype(int)#

    #
    # 'eqtl_format' must be specified, to make sure the users know what they're doing.
    #
    # Possible settings for 'eqtl_format':
    #   - tstat
    #   - effect_size
    #   - chisq
    #

    if 'zscore' in eqtl_table.columns.values:
        eqtl_table = eqtl_table.rename(index=str, columns={"zscore": "ZSCORE"})

    if settings['eqtl_experiments'][eqtl_file]['eqtl_format'] == 'tstat':
        assert 't-stat' or "tstat" in eqtl_table
        if "tstat" in eqtl_table:
            eqtl_table['t-stat'] = eqtl_table["tstat"]
        eqtl_table['ZSCORE'] = eqtl_table['t-stat']
    elif settings['eqtl_experiments'][eqtl_file]['eqtl_format'] == 'effect_size':
        assert 'beta' in eqtl_table
        eqtl_table['ZSCORE'] = eqtl_table['beta'] / eqtl_table['se']
        eqtl_table['pvalue'] = stats.norm.sf(abs(eqtl_table['beta'] / eqtl_table['se']))*2
    elif settings['eqtl_experiments'][eqtl_file]['eqtl_format'] == 'chisq':
        assert "chisq" in eqtl_table
        # Here we're dealing with RASQUAL data
        # where effect size is given by allelic imbalance percentage pi.
        # Use max function to protect against underflow in chi2 computation
        eqtl_table['pvalue'] = stats.chi2.sf(eqtl_table["chisq"],1)
        eqtl_table['ZSCORE'] = stats.norm.isf(eqtl_table['pvalue']/2) * (2 * (eqtl_table["pi"] > 0.5) - 1)
    elif settings['eqtl_experiments'][eqtl_file]['eqtl_format'] == 'pval_only':
        assert 'pvalue' in eqtl_table and ("effect_direction" in eqtl_table or "beta" in eqtl_table)
        # Need to cap it at z-score of 40 for outrageous p-values (like with AMD / RPE stuff)
        if "effect_direction" in eqtl_table:
            eqtl_table['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(eqtl_table["pvalue"] / 2)], index=eqtl_table.index) * (2*(eqtl_table["effect_direction"] == "+")-1)
        else:
            eqtl_table['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(eqtl_table["pvalue"] / 2)], index=eqtl_table.index) * (2*(eqtl_table["beta"] > 0)-1)
    else:
        return "Improper eQTL format specification"
    eqtl_table = eqtl_table[~eqtl_table["pvalue"].isna()]
    eqtl_table = eqtl_table[~eqtl_table["ZSCORE"].isna()]

    if 'ZSCORE' in eqtl_table.columns.values:
        # Derive beta and se from zscore if needed
        if 'se' not in eqtl_table.columns.values or 'beta' not in eqtl_table.columns.values:
            eqtl_table['beta'] = eqtl_table['ZSCORE']
            eqtl_table['se'] = 1

    if "beta" in eqtl_table:
        eqtl_table = eqtl_table.rename(index=str, columns={"beta": "beta_eqtl"})
        eqtl_table = eqtl_table.fillna({'beta': 0})
    if "se" in eqtl_table:
        eqtl_table = eqtl_table.rename(index=str, columns={"se": "se_eqtl"})
    
    return eqtl_table

# Input: GWAS pandas dataframe, eQTL pandas dataframe, gene name as a string,
#   GWAS SNP as a tuple.
# Returns: a combined table of summary statistics, or None if we need to skip
#   the site due to insufficient data.
def combine_summary_statistics(gwas_data, eqtl_data, gene, snp, settings, unsafe=False, allow_insignificant_gwas=False):

    window = settings["window"]

    # Filter SNPs down to the gene of interest.
    eqtl_subset = eqtl_data[eqtl_data['gene'] == gene].copy()

    if eqtl_subset.shape[0] == 0:
        return "The pre-specified gene was not tested in this sample."

    # Sometimes the GWAS SNP is outside of the range of eQTLs tested for a certain
    # gene, or on the outside fringe of the range. If this is the case, then skip it.
    # NOTE: Modify the 50000 cutoff if it doesn't seem like it's giving enough room for LD decay to fall off.

    #if snp.pos > max(eqtl_subset['snp_pos']) - 50000 or snp.pos < min(eqtl_subset['snp_pos']) + 50000:
    #        return "SNP outside range."

    # If not explicitly allowing them, remove pvalues with danger
    # of underflow.

    # TODO: This should also be fixable

    if min(eqtl_subset['pvalue']) < 1e-150:
        if unsafe:
            eqtl_subset['pvalue'] = eqtl_subset['pvalue'].apply(lambda x: max(x, 1e-150))
        else:
            return "eQTL pvalue underflow."

    if min(gwas_data['pvalue']) < 1e-150:
        if unsafe:
            gwas_data['pvalue'] = gwas_data['pvalue'].apply(lambda x: max(x, 1e-150))
        else:
            return "GWAS pvalue underflow."

    # Make sure all eQTLs are significant enough that this site is worth testing
    if "screening_thresholds" in settings and "eqtl" in settings["screening_thresholds"]:
        if min(eqtl_subset['pvalue']) > settings["screening_thresholds"]["eqtl"]:
            return "Insignificant eQTL top hit: -logp {0}".format(max([-math.log10(p) for p in eqtl_subset['pvalue']]))

    # NOTE: At some point, we may want to do all 1K genomes filtering here by default, if necessary.

    combined = pd.merge(gwas_data, eqtl_subset, on="snp_pos", suffixes=("_gwas", "_eqtl"))
   
    # For now, remove all positions that appear multiple times in the GWAS table.
    # This will avoid problems later in the pipeline, and doesn't remove too many SNPs anyway.
    # NOTE: This might not actually be necessary at this point in the process, but we'll keep it just in case.
    dup_counts = {}
    for pos in combined['snp_pos']:
            dup_counts[pos] = dup_counts.get(pos, 0) + 1

    combined['dup_counts'] = [dup_counts[pos] for pos in combined['snp_pos']]
    combined = combined[combined['dup_counts'] == 1]

    # Check to make sure there are SNPs remaining; if not, just move on
    # to next gene.
    if combined.shape[0] == 0:
        return "No overlapping SNPs in eQTL and GWAS"

    # Check to make sure we still have significant GWAS hits and eQTLs, if desired
    if "screening_thresholds" in settings and "gwas" in settings["screening_thresholds"]:
        if min(combined['pvalue_gwas']) > settings["screening_thresholds"]["gwas"]:
            return "No significant GWAS SNPs are in eQTL dataset (too rare)"

    return combined

