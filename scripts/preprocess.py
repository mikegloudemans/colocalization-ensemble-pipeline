# Author: Mike Gloudemans
#
# preprocess.py
#
# Tools for loading summary statistics.
#

import subprocess
import pandas as pd
import operator
import SNP
from scipy import stats
import math
import gzip

import sys
if sys.version_info[0] < 3:
    from StringIO import StringIO
else:
    from io import StringIO

# Load a list of SNPs generated by the "overlap" function,
# to test these SNPs only.
# TODO: Obviate the need for a separate dispatcher script
# altogether by just loading and launching directly from the
# list generated by "overlap"
def select_snps_from_list(list_file):

    gwas_table = pd.read_csv(list_file, sep="\s+", header=None)

    snp_list = zip(list(gwas_table.iloc[:,0]), list(gwas_table.iloc[:,1]), [-1]*gwas_table.shape[0])
    # Filter out X and Y for now
    snp_list = [s for s in snp_list if ("Y" not in str(s[0]) and "X" not in str(s[0]))]
    snp_list = [SNP.SNP(s) for s in snp_list]
    if gwas_table.shape[1] > 2:
        return zip(snp_list, list(gwas_table.iloc[:,2]))
    else:
        return zip(snp_list, [-1]*len(snp_list))

# Load summary statistics for GWAS
def get_gwas_data(gwas_file, snp, settings, trait):

    window = settings["window"]

    # Get GWAS data using tabix

    with gzip.open(gwas_file, 'rb') as gwas:
        header = gwas.readline()

    raw_gwas = subprocess.check_output("tabix {0} {1}:{2}-{3}".format(gwas_file, \
            snp.chrom, snp.pos - window, snp.pos + window), shell=True) + \
            subprocess.check_output("tabix {0} chr{1}:{2}-{3}".format(gwas_file, \
            snp.chrom, snp.pos - window, snp.pos + window), shell=True)
    gwas_table = pd.read_csv(StringIO(header + raw_gwas), sep="\t")
    gwas_table['pvalue'] = gwas_table['pvalue'].astype(float)

    if trait != gwas_file.split("/")[-1]:
        gwas_table = gwas_table[gwas_table["trait"] == trait]

    if gwas_table.shape[0] == 0:
        return "No GWAS summary statistics found at this locus."

    gwas_table['snp_pos'] = gwas_table['snp_pos'].astype(int)

    if "ref_allele_header" in settings['gwas_experiments'][gwas_file]:
        gwas_table['ref'] = gwas_table[settings['gwas_experiments'][gwas_file]['ref_allele_header']].str.upper()
    if "alt_allele_header" in settings['gwas_experiments'][gwas_file]:
        gwas_table['alt'] = gwas_table[settings['gwas_experiments'][gwas_file]['alt_allele_header']].str.upper()

    if "effect_allele" in list(gwas_table.columns.values):
        gwas_table['alt'] = gwas_table["effect_allele"].str.upper()
        gwas_table['ref'] = gwas_table["non_effect_allele"].str.upper()

    if 'effect_af' in gwas_table.columns.values:
        gwas_table = gwas_table.rename(index=str, columns={"effect_af": "effect_af_gwas"})

        gwas_table['alt'] = gwas_table['e']
        gwas_table['ref'] = gwas_table['ref'].apply(lambda x: x.upper())
        gwas_table['alt'] = gwas_table['alt'].apply(lambda x: x.upper())

    #
    # 'gwas_format' must be specified, to make sure the users know what they're doing.
    #
    # Possible settings for 'gwas_format':
    #   - case_control
    #   - effect_size
    #   - pval_only (requires effect direction)
    #

    if settings['gwas_experiments'][gwas_file]['gwas_format'] == 'case_control':
        assert 'log_or' in gwas_table and 'se' in gwas_table
        gwas_table['ZSCORE'] = gwas_table['log_or'] / gwas_table['se']
    elif settings['gwas_experiments'][gwas_file]['gwas_format'] == 'effect_size':
        if "log_or" in gwas_table:
            gwas_table['beta'] = gwas_table['log_or']
        assert 'beta' in gwas_table
        gwas_table['ZSCORE'] = gwas_table['beta'] / gwas_table['se']
        gwas_table['ZSCORE'] = gwas_table['ZSCORE'].fillna(0)
    elif settings['gwas_experiments'][gwas_file]['gwas_format'] == 'pval_only':
        gwas_table = gwas_table[~gwas_table["pvalue"].isna()]

        # Need to cap it at z-score of 40 for outrageous p-values (like with AMD / RPE stuff)
        if "effect_direction" in gwas_table:
            gwas_table['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(gwas_table["pvalue"] / 2)], index=gwas_table.index) * (2*(gwas_table["effect_direction"] == "+")-1)
        elif "beta" in gwas_table:
            # replace beta == NaN with 0 (beta == NaN for large p-values)
            gwas_table = gwas_table.fillna({'beta': 0})
            gwas_table['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(gwas_table["pvalue"] / 2)], index=gwas_table.index) * (2*(gwas_table["beta"] > 0)-1)
        elif "direction" in gwas_table:
            gwas_table['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(gwas_table["pvalue"] / 2)], index=gwas_table.index) * (2*(gwas_table["direction"] == "+")-1)
        else:
            # We don't always need zscore. Like not if running FINEMAP
            pass
    else:
        return "Improper GWAS format specification"

    if "beta" in gwas_table:
        gwas_table = gwas_table.rename(index=str, columns={"beta": "beta_gwas"})
    if "se" in gwas_table:
        gwas_table = gwas_table.rename(index=str, columns={"se": "se_gwas"})

    return gwas_table

# Load summary statistics for eQTL
def get_eqtl_data(eqtl_file, snp, settings):

    window = settings["window"]

    # Get eQTL data using tabix
    with gzip.open(eqtl_file, 'rb') as eqtl:
        header = eqtl.readline()

    raw_eqtls = subprocess.check_output("tabix {0} {1}:{2}-{3}".format(eqtl_file, \
            snp.chrom, snp.pos - window, snp.pos + window), shell=True)
    raw_eqtls += subprocess.check_output("tabix {0} chr{1}:{2}-{3}".format(eqtl_file, \
            snp.chrom, snp.pos - window, snp.pos + window), shell=True)
    eqtls = pd.read_csv(StringIO(header + raw_eqtls), sep="\t", index_col=False)

    if eqtls.shape[0] == 0:
        return "Gene desert."

    if "ref_allele_header" in settings['eqtl_experiments'][eqtl_file]:
        eqtls['ref'] = eqtls[settings['eqtl_experiments'][eqtl_file]['ref_allele_header']]
    if "alt_allele_header" in settings['eqtl_experiments'][eqtl_file]:
        eqtls['alt'] = eqtls[settings['eqtl_experiments'][eqtl_file]['alt_allele_header']]

    # NOTE: We're not worrying about direction here right now, but might want to later
    if "maf" in eqtls.columns.values:
        eqtls['effect_af_eqtl'] = eqtls['maf']

    if "effect_af" in eqtls.columns.values:
        eqtls = eqtls.rename(index=str, columns={"effect_af": "effect_af_eqtl"})

    if "ref" in eqtls.columns.values:
        eqtls['ref'] = eqtls['ref'].apply(lambda x: x.upper())
        eqtls['alt'] = eqtls['alt'].apply(lambda x: x.upper())

    eqtls['snp_pos'] = eqtls['snp_pos'].astype(int)#

    #
    # 'eqtl_format' must be specified, to make sure the users know what they're doing.
    #
    # Possible settings for 'eqtl_format':
    #   - tstat
    #   - effect_size
    #   - chisq
    #

    if settings['eqtl_experiments'][eqtl_file]['eqtl_format'] == 'tstat':
        assert 't-stat' or "tstat" in eqtls
        if "tstat" in eqtls:
            eqtls['t-stat'] = eqtls["tstat"]
        eqtls['ZSCORE'] = eqtls['t-stat']
    elif settings['eqtl_experiments'][eqtl_file]['eqtl_format'] == 'effect_size':
        assert 'beta' in eqtls
        eqtls['ZSCORE'] = eqtls['beta'] / eqtls['se']
        eqtls['pvalue'] = stats.norm.sf(abs(eqtls['beta'] / eqtls['se']))*2
    elif settings['eqtl_experiments'][eqtl_file]['eqtl_format'] == 'chisq':
        assert "chisq" in eqtls
        # Here we're dealing with RASQUAL data
        # where effect size is given by allelic imbalance percentage pi.
        # Use max function to protect against underflow in chi2 computation
        eqtls['pvalue'] = stats.chi2.sf(eqtls["chisq"],1)
        eqtls['ZSCORE'] = stats.norm.isf(eqtls['pvalue']/2) * (2 * (eqtls["pi"] > 0.5) - 1)
    elif settings['eqtl_experiments'][eqtl_file]['eqtl_format'] == 'pval_only':
        assert 'pvalue' in eqtls and ("effect_direction" in eqtls or "beta" in eqtls)
        # Need to cap it at z-score of 40 for outrageous p-values (like with AMD / RPE stuff)
        if "effect_direction" in eqtls:
            eqtls['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(eqtls["pvalue"] / 2)], index=eqtls.index) * (2*(eqtls["effect_direction"] == "+")-1)
        else:
            eqtls['ZSCORE'] = pd.Series([min(x, 40) for x in stats.norm.isf(eqtls["pvalue"] / 2)], index=eqtls.index) * (2*(eqtls["beta"] > 0)-1)
    else:
        return "Improper eQTL format specification"
    eqtls = eqtls[~eqtls["pvalue"].isna()]
    eqtls = eqtls[~eqtls["ZSCORE"].isna()]

    if "beta" in eqtls:
        eqtls = eqtls.rename(index=str, columns={"beta": "beta_eqtl"})
        eqtls = eqtls.fillna({'beta': 0})
    if "se" in eqtls:
        eqtls = eqtls.rename(index=str, columns={"se": "se_eqtl"})

    return eqtls

# Input: GWAS pandas dataframe, eQTL pandas dataframe, gene name as a string,
#   GWAS SNP as a tuple.
# Returns: a combined table of summary statistics, or None if we need to skip
#   the site due to insufficient data.
def combine_summary_statistics(gwas_data, eqtl_data, gene, snp, settings, unsafe=False, allow_insignificant_gwas=False):

    window = settings["window"]

    # Filter SNPs down to the gene of interest.
    eqtl_subset = eqtl_data[eqtl_data['gene'] == gene].copy()

    if eqtl_subset.shape[0] == 0:
        return "The pre-specified gene was not tested in this sample."

    # Sometimes the GWAS SNP is outside of the range of eQTLs tested for a certain
    # gene, or on the outside fringe of the range. If this is the case, then skip it.
    # NOTE: Modify the 50000 cutoff if it doesn't seem like it's giving enough room for LD decay to fall off.

    if snp.pos > max(eqtl_subset['snp_pos']) - 50000 or snp.pos < min(eqtl_subset['snp_pos']) + 50000:
            return "SNP outside range."

    # If not explicitly allowing them, remove pvalues with danger
    # of underflow.

    # TODO: This should also be fixable

    if min(eqtl_subset['pvalue']) < 1e-150:
        if unsafe:
            eqtl_subset['pvalue'] = eqtl_subset['pvalue'].apply(lambda x: max(x, 1e-150))
        else:
            return "eQTL pvalue underflow."

    if min(gwas_data['pvalue']) < 1e-150:
        if unsafe:
            gwas_data['pvalue'] = gwas_data['pvalue'].apply(lambda x: max(x, 1e-150))
        else:
            return "GWAS pvalue underflow."

    # Make sure all eQTLs are significant enough that this site is worth testing
    if "screening_thresholds" in settings and "eqtl" in settings["screening_thresholds"]:
        if min(eqtl_subset['pvalue']) > settings["screening_thresholds"]["eqtl"]:
            return "Insignificant eQTL top hit: -logp {0}".format(max([-math.log10(p) for p in eqtl_subset['pvalue']]))

    # NOTE: At some point, we may want to do all 1K genomes filtering here by default, if necessary.

    combined = pd.merge(gwas_data, eqtl_subset, on="snp_pos", suffixes=("_gwas", "_eqtl"))
   
    # For now, remove all positions that appear multiple times in the GWAS table.
    # This will avoid problems later in the pipeline, and doesn't remove too many SNPs anyway.
    # NOTE: This might not actually be necessary at this point in the process, but we'll keep it just in case.
    dup_counts = {}
    for pos in combined['snp_pos']:
            dup_counts[pos] = dup_counts.get(pos, 0) + 1

    combined['dup_counts'] = [dup_counts[pos] for pos in combined['snp_pos']]
    combined = combined[combined['dup_counts'] == 1]

    # Check to make sure there are SNPs remaining; if not, just move on
    # to next gene.
    if combined.shape[0] == 0:
        return "No overlapping SNPs in eQTL and GWAS"

    # Check to make sure we still have significant GWAS hits and eQTLs, if desired
    if "screening_thresholds" in settings and "gwas" in settings["screening_thresholds"]:
        if min(combined['pvalue_gwas']) > settings["screening_thresholds"]["gwas"]:
            return "No significant GWAS SNPs are in eQTL dataset (too rare)"

    return combined

