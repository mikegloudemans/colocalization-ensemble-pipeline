#!/bin/python3

import sys
import os
import glob

## for test #############################################################
#srcdir = '/oak/stanford/groups/smontgom/nicolerg/src/brain_gwas'
base = '/oak/stanford/groups/smontgom/nicolerg/coloc-wrapper'
tmpdir = '/oak/stanford/groups/smontgom/nicolerg/tmp/coloc-wrapper'
os.chdir(base)
# make some directories 
subprocess.call('mkdir -p log/cluster', shell=True)
subprocess.call('mkdir -p {}'.format(tmpdir), shell=True)

trait_set_1 = ['WojcikG_PMID_ckd_analysis']
trait_set_2 = ['Lung_global']
#########################################################################

# methods = config['colocalization_methods']
#
# def get_trait_set(set_number):
# 	trait_set = set()
# 	for trait in config['studies']:
# 		if 'trait_set' not in config['studies'][trait]:
# 			continue
# 		if config['studies'][trait]['trait_set'] == set_number:
# 			trait_set.add(trait)
# 	return(trait_set)
#
# # assume there are two sets of traits for now
# # all studies in trait_set_1 are tested against all studies in trait_set_2
# # we should probably also add the option to provide a two-column input of all desired trait comparisons
# trait_set_1 = get_trait_set(1)
# trait_set_2 = get_trait_set(2)
# if len(trait_set_1) == 0 or len(trait_set_2) == 0:
# 	sys.exit('Two sets of traits were not defined in the config file. (more detail...)')
# 
# 
# # here we define colocalization methods and trait combinations 
# rule all:
# 	input:
# 		expand('{method}/{trait1}.{trait2}.results.txt', 
# 			trait1 = trait_set_1, 
# 			trait2 = trait_set_2,
# 			method = methods)
#
# rule preprocess:
# 	input:
# 		config['studies']['{study}']['file']
# 	output:
# 		'summary_stats/{study}.formatted.summary_stats.txt.gz'
# 	shell:
# 		'''
# 		'''
# 
# rule overlap:
# 	input:
# 		trait1 = 'summary_stats/{trait1}.formatted.summary_stats.txt.gz',
# 		trait2 = 'summary_stats/{trait2}.formatted.summary_stats.txt.gz'
# 	output:
# 		'overlap/{trait1}.{trait2}.loci_to_test.txt'
# 	shell:
# 		'''
# 		'''

# rules that can be run on the login node
localrules: all,merge_results

rule all: 
	input:
		expand('merged/{trait1}.{trait2}.results.txt.gz', 
			trait1 = trait_set_1, 
			trait2 = trait_set_2)


checkpoint split_loci:
	input:
		'overlap/{trait1}.{trait2}.1000loci_to_test.txt'
	output:
		directory('{}/split_loci/{{trait1}}.{{trait2}}'.format(tmpdir))
	run:
		os.mkdir(output[0])
		# read in header first
		with open(input[0]) as f:
			header = f.readline()

		# write out one file per line
		n=0
		with open(input[0], 'r') as f:
			next(f) # skip header
			for line in f:
				with open('{}/split_loci/{}.{}/chunk{}.txt'.format(tmpdir, wildcards.trait1, wildcards.trait2, n), 'w') as o:
					o.write(header)
					o.write(line)
				n+=1

## do stuff (colocalization) with the splits

rule test_group_execution:
	input: 
		'{}/split_loci/{{trait1}}.{{trait2}}/chunk{{n}}.txt'.format(tmpdir) 
	output:
		'{}/processed_loci/{{trait1}}.{{trait2}}/chunk{{n}}.txt'.format(tmpdir) 
	group: 
		'coloc'
	shell:
		'''
		for i in {{1..60}}; do 
			echo ${{i}} >> {output} 
			sleep 1
		done
		'''

# def collect_splits(wildcards):
# 	checkpoint_output = checkpoints.split_loci.get(**wildcards).output[0]
# 	print(checkpoint_output)
# 	# /tmp/coloc-wrapper/split_loci/WojcikG_PMID_ckd_analysis.Lung_global
# 	print(glob.glob('{}/chunk*txt'.format(checkpoint_output)))
# 	# /tmp/coloc-wrapper/split_loci/WojcikG_PMID_ckd_analysis.Lung_global/chunk2715.txt
# 	return glob.glob('{}/chunk*txt'.format(checkpoint_output))

def collect_processed_splits(wildcards):
	checkpoint_output = checkpoints.split_loci.get(**wildcards).output[0]
	all_chunks = glob.glob('{}/chunk*txt'.format(checkpoint_output))
	processed = [x.replace('split_loci', 'processed_loci') for x in all_chunks]
	return processed

rule merge_results:
	input:
		collect_processed_splits
	output:
		'merged/{trait1}.{trait2}.results.txt.gz'
	shell:
		'''
		cat {input} > {output}
		'''

# rule merge_results:
# 	input:
# 		collect_splits
# 	output:
# 		'merged/{trait1}.{trait2}.results.txt.gz'
# 	shell:
# 		'''
# 		cat {input} > merged/{wildcards.trait1}.{wildcards.trait2}.results.tmp.txt
# 		# remove all but first header
# 		head -1 merged/{wildcards.trait1}.{wildcards.trait2}.results.tmp.txt > merged/{wildcards.trait1}.{wildcards.trait2}.results.txt
# 		grep -v "^chr	" merged/{wildcards.trait1}.{wildcards.trait2}.results.tmp.txt >> merged/{wildcards.trait1}.{wildcards.trait2}.results.txt
# 		rm merged/{wildcards.trait1}.{wildcards.trait2}.results.tmp.txt
# 		gzip merged/{wildcards.trait1}.{wildcards.trait2}.results.txt
# 		'''




## NOT USED YET
# 
# rule coloc:
# 	input:
# 		'overlap/{trait1}.{trait2}.{n}.txt'
# 	output:
# 		temp('coloc/{trait1}.{trait2}.{n}.results.txt')
# 	group:
# 		'coloc'
# 	params:
# 		trait1_cc = config['studies']['{trait1}']['cc'],
# 		trait2_cc = config['studies']['{trait2}']['cc'],
# 		trait1_N = config['studies']['{trait1}']['N'],
# 		trait2_N = config['studies']['{trait2}']['N']
# 	shell:
# 		'''
# 		# run coloc for the locus 
# 		python coloc.py {input} {param.trait1_cc} {param.trait1_N} ...
# 		'''
#
# rule finemap:
# 	input:
# 		'overlap/{trait1}.{trait2}.{n}.txt'
# 	output:
# 		temp('finemap/{trait1}.{trait2}.{n}.results.txt')
# 	group:
# 		'finemap'
# 	shell:
# 		'''
# 		# run finemap for the locus 
# 		'''
